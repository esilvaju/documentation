---
id: event_type
title: Event Types
---

## Event Types

Event types offer key advantages such as improved code organization and maintainability, flexibility for customization, and enabling responsive applications. They categorize events, allowing for modular code, tailored event-driven systems, and targeted event handling. Overall, event types enhance code structure, flexibility, and responsiveness, leading to more robust applications.

### Rucio Event Types

| Context                                                                                    | Event Type      | Payload                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|--------------------------------------------------------------------------------------------|-----------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| While adding a DID, if the DID type is a Container                                         | CREATE_CNT      | message = {'account': account.external, 'scope': did['scope'].external,'name': did['name'],'expired_at': str(expired_at) if expired_at is not None else None}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| While adding a DID, if the DID type is a DataSet                                           | CREATE_DTS      | message = {'account': account.external, 'scope': did['scope'].external,'name': did['name'],'expired_at': str(expired_at) if expired_at is not None else None}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Submit transfer requests on destination RSEs for data identifiers.                         | transfer_status | payload = {'request-id': new_request['id'],  'request-type': request['request_type'].name.lower(),  'scope': request['scope'].external,  'name': request['name'],  'dst-rse-id': request['dest_rse_id'],  'dst-rse': dest_rse_name,  'state': request['state'].name.lower(),  'retry-count': request['retry_count'],  'rule-id': str(request['rule_id']),  'activity': request['attributes']['activity'],  'file-size': request['attributes']['bytes'],  'bytes': request['attributes']['bytes'],  'checksum-md5': request['attributes']['md5'],  'checksum-adler': request['attributes']['adler32'],  'queued_at': str(datetime.datetime.utcnow())} |
| Schedule removal of the entry from the DIDs table                                          | INCOMPLETE      | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Delete empty DIDs where the DIDType is DATASET                                             | ERASE           | payload': dumps({'scope': scope.external, 'name': name, 'account': 'root'})})                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| When the replication rule transitioning into OK_STATE for DIDs which are closed            | RULE_OK         | if not did['open']: payload = {'scope': rule.scope.external, 'name': rule.name, 'rule_id': rule.id}  if rule.scope.vo != 'def': payload['vo'] = rule.scope.vo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| For replication replication rule, for each 10% of progress                                 | RULE_PROGRESS   | if rule.notification == RuleNotification.PROGRESS: payload = {'scope': rule.scope.external, 'name': rule.name, 'rule_id': rule.id, 'progress': __progress_class(rule.locks_replicating_cnt, total_locks)}  if rule.scope.vo != 'def': payload['vo'] = rule.scope.vo                                                                                                                                                                                                                                                                                                                                                                                  |
| When the replication rule transitioning into OK_STATE for each DATASET covered by the rule | DATASETLOCK_OK  | for dataset_lock in dataset_locks: payload = {'scope': dataset_lock.scope.external, 'name': dataset_lock.name, 'rse': get_rse_name(rse_id=dataset_lock.rse_id, session=session), 'rse_id': dataset_lock.rse_id, 'rule_id': rule.id}  if dataset_lock.scope.vo != 'def': payload['vo'] = dataset_lock.scope.vo                                                                                                                                                                                                                                                                                                                                        |

